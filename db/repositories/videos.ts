import { eq } from "drizzle-orm";
import { db, videos, transcripts } from "../index";
import type { Video, NewVideo, Transcript, NewTranscript } from "../schema";

// Generate a simple unique ID
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2);
}

export interface TranscriptSegment {
  start: number;
  end: number;
  text: string;
}

export interface VideoWithTranscripts extends Video {
  transcripts: Array<{
    language: string;
    isAutoGenerated: boolean;
    segments: TranscriptSegment[];
  }>;
}

// Get all videos
export function getAllVideos(): Video[] {
  return db.select().from(videos).all();
}

// Get video by ID
export function getVideoById(id: string): Video | undefined {
  return db.select().from(videos).where(eq(videos.id, id)).get();
}

// Get video with all transcripts
export function getVideoWithTranscripts(
  id: string
): VideoWithTranscripts | undefined {
  const video = getVideoById(id);
  if (!video) return undefined;

  const videoTranscripts = db
    .select()
    .from(transcripts)
    .where(eq(transcripts.videoId, id))
    .all();

  return {
    ...video,
    transcripts: videoTranscripts.map((t) => ({
      language: t.language,
      isAutoGenerated: t.isAutoGenerated ?? false,
      segments: t.segmentsJson ? JSON.parse(t.segmentsJson) : [],
    })),
  };
}

// Get all videos with their primary transcript
export function getAllVideosWithPrimaryTranscript(): Array<
  Video & { transcript?: { language: string; segments: TranscriptSegment[] } }
> {
  const allVideos = getAllVideos();
  console.log(`[VideoRepo] getAllVideosWithPrimaryTranscript: ${allVideos.length} videos`);

  return allVideos.map((video) => {
    // Get the first transcript (prefer non-auto-generated)
    const transcript = db
      .select()
      .from(transcripts)
      .where(eq(transcripts.videoId, video.id))
      .orderBy(transcripts.isAutoGenerated)
      .get();

    console.log(
      `[VideoRepo] Video ${video.id}: found transcript=${!!transcript}, segmentsJson length=${transcript?.segmentsJson?.length ?? 0}`
    );

    if (!transcript) {
      return video;
    }

    const segments = transcript.segmentsJson
      ? JSON.parse(transcript.segmentsJson)
      : [];
    console.log(`[VideoRepo] Video ${video.id}: parsed ${segments.length} segments`);

    return {
      ...video,
      transcript: {
        language: transcript.language,
        segments,
      },
    };
  });
}

// Insert or update video
export function upsertVideo(
  videoData: Omit<NewVideo, "createdAt" | "updatedAt">
): Video {
  const now = Date.now();
  const existing = getVideoById(videoData.id);

  if (existing) {
    db.update(videos)
      .set({ ...videoData, updatedAt: now })
      .where(eq(videos.id, videoData.id))
      .run();
  } else {
    db.insert(videos)
      .values({ ...videoData, createdAt: now, updatedAt: now })
      .run();
  }

  return getVideoById(videoData.id)!;
}

// Update video local path
export function updateVideoLocalPath(id: string, localPath: string) {
  db.update(videos)
    .set({ localPath, updatedAt: Date.now() })
    .where(eq(videos.id, id))
    .run();
}

// Delete video
export function deleteVideo(id: string) {
  db.delete(videos).where(eq(videos.id, id)).run();
}

// Add or update transcript for video
export function upsertTranscript(
  videoId: string,
  language: string,
  segments: TranscriptSegment[],
  isAutoGenerated = false
): Transcript {
  const now = Date.now();
  console.log(
    `[VideoRepo] upsertTranscript: videoId=${videoId}, lang=${language}, segments=${segments?.length ?? 0}`
  );

  // Check if transcript exists
  const existing = db
    .select()
    .from(transcripts)
    .where(eq(transcripts.videoId, videoId))
    .all()
    .find((t) => t.language === language);

  const segmentsJson = JSON.stringify(segments);
  console.log(`[VideoRepo] segmentsJson length: ${segmentsJson.length}`);

  if (existing) {
    console.log(`[VideoRepo] Updating existing transcript: ${existing.id}`);
    db.update(transcripts)
      .set({ segmentsJson, isAutoGenerated, updatedAt: now })
      .where(eq(transcripts.id, existing.id))
      .run();
    return db
      .select()
      .from(transcripts)
      .where(eq(transcripts.id, existing.id))
      .get()!;
  }

  const id = generateId();
  console.log(`[VideoRepo] Inserting new transcript: ${id}`);
  db.insert(transcripts)
    .values({
      id,
      videoId,
      language,
      isAutoGenerated,
      segmentsJson,
      createdAt: now,
      updatedAt: now,
    })
    .run();

  const result = db.select().from(transcripts).where(eq(transcripts.id, id)).get();
  console.log(`[VideoRepo] Insert result: ${result ? "success" : "failed"}`);
  return result!;
}

// Get all transcripts for a video
export function getTranscriptsForVideo(videoId: string): Transcript[] {
  return db
    .select()
    .from(transcripts)
    .where(eq(transcripts.videoId, videoId))
    .all();
}

// Get available languages for a video
export function getAvailableLanguages(videoId: string): string[] {
  const videoTranscripts = getTranscriptsForVideo(videoId);
  return videoTranscripts.map((t) => t.language);
}
