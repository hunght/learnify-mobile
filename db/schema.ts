import { sqliteTable, text, integer, index, unique } from "drizzle-orm/sqlite-core";

// Videos table - core video metadata
export const videos = sqliteTable(
  "videos",
  {
    id: text("id").primaryKey(), // YouTube video ID
    title: text("title").notNull(),
    channelTitle: text("channel_title").notNull(),
    duration: integer("duration").notNull(), // seconds
    thumbnailUrl: text("thumbnail_url"),
    localPath: text("local_path"), // Local file path after download
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [index("videos_updated_at_idx").on(table.updatedAt)]
);

// Transcripts table - multiple languages per video
export const transcripts = sqliteTable(
  "transcripts",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }),
    language: text("language").notNull(), // ISO code: "en", "es", etc.
    isAutoGenerated: integer("is_auto_generated", { mode: "boolean" }).default(
      false
    ),
    segmentsJson: text("segments_json"), // JSON array of {start, end, text}
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("transcripts_video_id_idx").on(table.videoId),
    unique().on(table.videoId, table.language),
  ]
);

// Translation cache - word/phrase translations
export const translationCache = sqliteTable(
  "translation_cache",
  {
    id: text("id").primaryKey(),
    sourceText: text("source_text").notNull(),
    sourceLang: text("source_lang").notNull(),
    targetLang: text("target_lang").notNull(),
    translatedText: text("translated_text").notNull(),
    detectedLang: text("detected_lang"),
    queryCount: integer("query_count").notNull().default(1),
    firstQueriedAt: integer("first_queried_at").notNull(),
    lastQueriedAt: integer("last_queried_at").notNull(),
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    unique().on(table.sourceText, table.sourceLang, table.targetLang),
    index("translation_cache_lookup_idx").on(
      table.sourceText,
      table.sourceLang,
      table.targetLang
    ),
    index("translation_cache_query_count_idx").on(table.queryCount),
  ]
);

// Translation contexts - links translations to video timestamps
export const translationContexts = sqliteTable(
  "translation_contexts",
  {
    id: text("id").primaryKey(),
    translationId: text("translation_id")
      .notNull()
      .references(() => translationCache.id, { onDelete: "cascade" }),
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }),
    timestampSeconds: integer("timestamp_seconds").notNull(),
    contextText: text("context_text"),
    createdAt: integer("created_at").notNull(),
  },
  (table) => [
    index("translation_contexts_translation_id_idx").on(table.translationId),
    index("translation_contexts_video_id_idx").on(table.videoId),
    unique().on(table.translationId, table.videoId, table.timestampSeconds),
  ]
);

// Saved words - vocabulary learning list
export const savedWords = sqliteTable(
  "saved_words",
  {
    id: text("id").primaryKey(),
    translationId: text("translation_id")
      .notNull()
      .references(() => translationCache.id, { onDelete: "cascade" }),
    notes: text("notes"),
    reviewCount: integer("review_count").notNull().default(0),
    lastReviewedAt: integer("last_reviewed_at"),
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("saved_words_translation_id_idx").on(table.translationId),
    unique().on(table.translationId),
  ]
);

// Flashcards for spaced repetition
export const flashcards = sqliteTable(
  "flashcards",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id").references(() => videos.id, {
      onDelete: "set null",
    }),
    frontContent: text("front_content").notNull(),
    backContent: text("back_content").notNull(),
    contextText: text("context_text"),
    timestampSeconds: integer("timestamp_seconds"),
    difficulty: integer("difficulty").default(0), // 0=new, 1=easy, 2=medium, 3=hard
    nextReviewAt: integer("next_review_at"),
    reviewCount: integer("review_count").default(0),
    easeFactor: integer("ease_factor").default(250), // SM-2 algorithm (x100)
    interval: integer("interval").default(0), // Days until next review
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("flashcards_video_id_idx").on(table.videoId),
    index("flashcards_next_review_idx").on(table.nextReviewAt),
  ]
);

// Watch stats per video
export const watchStats = sqliteTable(
  "watch_stats",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id")
      .notNull()
      .unique()
      .references(() => videos.id, { onDelete: "cascade" }),
    totalWatchSeconds: integer("total_watch_seconds").default(0),
    lastPositionSeconds: integer("last_position_seconds").default(0),
    lastWatchedAt: integer("last_watched_at"),
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("watch_stats_video_id_idx").on(table.videoId),
    index("watch_stats_last_watched_idx").on(table.lastWatchedAt),
  ]
);

// TypeScript types
export type Video = typeof videos.$inferSelect;
export type NewVideo = typeof videos.$inferInsert;

export type Transcript = typeof transcripts.$inferSelect;
export type NewTranscript = typeof transcripts.$inferInsert;

export type TranslationCacheEntry = typeof translationCache.$inferSelect;
export type NewTranslationCacheEntry = typeof translationCache.$inferInsert;

export type TranslationContext = typeof translationContexts.$inferSelect;
export type NewTranslationContext = typeof translationContexts.$inferInsert;

export type SavedWord = typeof savedWords.$inferSelect;
export type NewSavedWord = typeof savedWords.$inferInsert;

export type Flashcard = typeof flashcards.$inferSelect;
export type NewFlashcard = typeof flashcards.$inferInsert;

export type WatchStat = typeof watchStats.$inferSelect;
export type NewWatchStat = typeof watchStats.$inferInsert;
