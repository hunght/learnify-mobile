import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import type { Video, Transcript } from "../types";
import * as videoRepo from "../db/repositories/videos";

interface LibraryStore {
  videos: Video[];
  isLoaded: boolean;

  // Load videos from SQLite
  loadVideos: () => void;

  // Video CRUD
  addVideo: (video: Video) => void;
  updateVideo: (id: string, updates: Partial<Video>) => void;
  removeVideo: (id: string) => void;
  getVideo: (id: string) => Video | undefined;
  clearLibrary: () => void;

  // Transcript management
  addTranscript: (videoId: string, transcript: Transcript) => void;
  getTranscripts: (videoId: string) => Transcript[];
}

// Convert DB video to app Video type
function dbVideoToVideo(
  dbVideo: videoRepo.VideoWithTranscripts | ReturnType<typeof videoRepo.getAllVideosWithPrimaryTranscript>[number]
): Video {
  const video: Video = {
    id: dbVideo.id,
    title: dbVideo.title,
    channelTitle: dbVideo.channelTitle,
    duration: dbVideo.duration,
    thumbnailUrl: dbVideo.thumbnailUrl ?? undefined,
    localPath: dbVideo.localPath ?? undefined,
  };

  // Handle transcripts
  if ("transcripts" in dbVideo && Array.isArray(dbVideo.transcripts)) {
    video.transcripts = dbVideo.transcripts;
    // Set primary transcript (first non-auto-generated, or first)
    const primary =
      dbVideo.transcripts.find((t) => !t.isAutoGenerated) ??
      dbVideo.transcripts[0];
    if (primary) {
      video.transcript = primary;
    }
  } else if ("transcript" in dbVideo && dbVideo.transcript) {
    video.transcript = dbVideo.transcript;
  }

  return video;
}

export const useLibraryStore = create<LibraryStore>()(
  subscribeWithSelector((set, get) => ({
    videos: [],
    isLoaded: false,

    loadVideos: () => {
      try {
        const dbVideos = videoRepo.getAllVideosWithPrimaryTranscript();
        const videos = dbVideos.map(dbVideoToVideo);
        set({ videos, isLoaded: true });
        console.log("[Library] Loaded", videos.length, "videos from SQLite");
        // Debug: log transcript info for each video
        for (const v of videos) {
          console.log(
            `[Library] Video ${v.id}: transcript=${!!v.transcript}, segments=${v.transcript?.segments?.length ?? 0}`
          );
        }
      } catch (error) {
        console.error("[Library] Failed to load videos:", error);
        set({ isLoaded: true });
      }
    },

    addVideo: (video) => {
      try {
        // Upsert to SQLite
        videoRepo.upsertVideo({
          id: video.id,
          title: video.title,
          channelTitle: video.channelTitle,
          duration: video.duration,
          thumbnailUrl: video.thumbnailUrl ?? null,
          localPath: video.localPath ?? null,
        });

        // Add transcripts if provided
        if (video.transcripts) {
          console.log(
            `[Library] Storing ${video.transcripts.length} transcripts for ${video.id}`
          );
          for (const transcript of video.transcripts) {
            console.log(
              `[Library] Storing transcript: lang=${transcript.language}, segments=${transcript.segments?.length ?? 0}`
            );
            videoRepo.upsertTranscript(
              video.id,
              transcript.language,
              transcript.segments,
              transcript.isAutoGenerated ?? false
            );
          }
        } else if (video.transcript) {
          console.log(
            `[Library] Storing single transcript: lang=${video.transcript.language}, segments=${video.transcript.segments?.length ?? 0}`
          );
          videoRepo.upsertTranscript(
            video.id,
            video.transcript.language,
            video.transcript.segments,
            video.transcript.isAutoGenerated ?? false
          );
        } else {
          console.log(`[Library] No transcript provided for ${video.id}`);
        }

        // Reload videos from DB
        get().loadVideos();
      } catch (error) {
        console.error("[Library] Failed to add video:", error);
      }
    },

    updateVideo: (id, updates) => {
      try {
        const existing = videoRepo.getVideoById(id);
        if (!existing) {
          console.warn("[Library] Video not found for update:", id);
          return;
        }

        videoRepo.upsertVideo({
          id,
          title: updates.title ?? existing.title,
          channelTitle: updates.channelTitle ?? existing.channelTitle,
          duration: updates.duration ?? existing.duration,
          thumbnailUrl: updates.thumbnailUrl ?? existing.thumbnailUrl,
          localPath: updates.localPath ?? existing.localPath,
        });

        // Handle transcript updates
        if (updates.transcripts) {
          for (const transcript of updates.transcripts) {
            videoRepo.upsertTranscript(
              id,
              transcript.language,
              transcript.segments,
              transcript.isAutoGenerated ?? false
            );
          }
        } else if (updates.transcript) {
          videoRepo.upsertTranscript(
            id,
            updates.transcript.language,
            updates.transcript.segments,
            updates.transcript.isAutoGenerated ?? false
          );
        }

        // Reload videos from DB
        get().loadVideos();
      } catch (error) {
        console.error("[Library] Failed to update video:", error);
      }
    },

    removeVideo: (id) => {
      try {
        videoRepo.deleteVideo(id);
        get().loadVideos();
      } catch (error) {
        console.error("[Library] Failed to remove video:", error);
      }
    },

    getVideo: (id) => get().videos.find((v) => v.id === id),

    clearLibrary: () => {
      try {
        const videos = get().videos;
        for (const video of videos) {
          videoRepo.deleteVideo(video.id);
        }
        set({ videos: [] });
      } catch (error) {
        console.error("[Library] Failed to clear library:", error);
      }
    },

    addTranscript: (videoId, transcript) => {
      try {
        videoRepo.upsertTranscript(
          videoId,
          transcript.language,
          transcript.segments,
          transcript.isAutoGenerated ?? false
        );
        get().loadVideos();
      } catch (error) {
        console.error("[Library] Failed to add transcript:", error);
      }
    },

    getTranscripts: (videoId) => {
      const video = get().videos.find((v) => v.id === videoId);
      return video?.transcripts ?? (video?.transcript ? [video.transcript] : []);
    },
  }))
);
